# !/usr/bin/env python
# -*- coding:utf-8 -*-

#async def
#async def 定义的是一个原生协程函数，而调用协程函数得到的返回值才是协程

async def read_data(db):
    data=await db.fetch('select * from db1')
    pass

#type(read_data) ,function,原生协程函数

#core=read_data(db)  type(core) coroutine 协程

async def func():
    await read_data(1)

#awaitable 对象有以下几种：
#   调用原生协程函数返回的原生协程
#被 @asyncio.coroutine 装饰的生成器函数调用返回的生成器协程
#实现了__await__方法的对象
#     __await_必须返回迭代器，否则会报typeerror，实现了 __await_的对象也被称为类似未来对象

#await 后只能跟awaitable对象，否则会报typeerror，await必须在async def内使用


async def say_hello():
    print('in say_hello')
    return 'Hello'

async def say_word():
    print('in say_word')
    return 'Word'

async def say_helloword():
    print('in say_helloword')
    value=await say_hello()+ await say_word()
    return value

import uvloop
import asyncio

事件循环策略

    # policy=asyncio.get_event_loop_policy() #<asyncio.unix_events._UnixDefaultEventLoopPolicy object at 0x10aa52b00>

    # policy=uvloop.EventLoopPolicy()
    # asyncio.set_event_loop_policy(policy)
    # policy=asyncio.get_event_loop_policy()  #<uvloop.EventLoopPolicy object at 0x10a04bda0>

    #uvloop 的事件循环效率高，asyncio内的事件循环稳定性高

事件循环
    每个python线程可以设置不同的事件循环
    
    获取当前事件循环：
        default_loop=asyncio.get_event_loop()    #一般写这一行就能获取到默认的事件循环
        default_loop=asyncio.get_event_loop_policy().get_event_loop()
        
    设置事件循环：
        asyncio.set_event_loop(loop)
        asyncio.get_event_loop_policy().set_event_loop(loop)
        
    生成事件循环：
        new_loop=asyncio.new_event_loop()
        new_loop=asyncio.get_event_loop_policy().new_event_loop()
    
    注1:同一个进程最好只使用一个事件循环策略，且在多线程下只使用该策略生成的事件循环对象
    注2:python只会为主线设置默认的事件循环策略，以及默认的事件循环，但不会为自线程设置，如果在子线程调用asyicio.get_event_loop()，会报runtimeerrorr
        方法1:在子线程设置新的事件循环对象，new_loop=asyncio.new_event_loop()
        方法2:把主线程的事件循环对象当参数传给子线程
    注3:除了子线程之外，其它地方只需要asyicio.get_event_loop()，得到的就是默认的事件循环
    
    执行完4个任务后退出：   
        import asyncio

        loop=asyncio.get_event_loop()


        for i in range(4):
            loop.create_task(say_hello()) #将协程封装成task对象，并加入loop进行调度
            if i==5:
                loop.stop() #会执行完所有已经加入loop的任务

        loop.run_forever()

    执行完6个任务后退出：
        import asyncio

        loop=asyncio.get_event_loop()


        for i in range(4):
            loop.create_task(say_hello()) #将协程封装成task对象，并加入loop进行调度
        loop.stop()

        for i in range(2):
            loop.create_task(say_hello()) #将协程封装成task对象，并加入loop进行调度
        loop.run_forever()
    结论：只要在run_forever之前加入的所有任务都会被执行

    loop.close()    强制关闭loop，毁灭性的，一般只使用loop.stop()
    注：正在运行中的loop是不能close的

    
    
    
        
    
   
    
    
    
    
        
    
    
  





